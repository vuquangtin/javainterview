# OCPJP 6 Mock Exam – 5
----
### Q 1 : Which of the following are the correct form of documentation comments?

1. //some text here
2. /*some text here*/
3. /**some text here*/
4. all the above

### Q 2 : State the correct formula for minimum/maximum values for integer primitives where no_of_bits is the size of the type in bits.

1. 2^(no_of_bits-1) / 2^(no_of_bits-1)+1
2. 2^(no_of_bits+1) / 2^(no_of_bits+1)+1
3. 2^(no_of_bits-1) / 2^(no_of_bits-1)-1
4. all the above

### Q 3 : Which of the following initializes boolean primitive?


1. Boolean flag=true;
2. boolean flag=true;
3. boolean flag=TRUE;
4. Boolean flag=TRUE;

### Q 4 : which of the following is the correct way to define a class that will be in the default package

1. package default;<br/>
import java.util.*;
2. import java.util.*;<br/>
 package default;
3. import java.util.*;
4. all the above

### Q 5 : Which of the following main method in a java application is correct?

1. public static void main(String[] args)
2. public void main(String args[])
3. public static void main (string[] args)
4. final public static void main (String[] args)
5. static public void main(String x[])
6. static void main (string[] args)
7. 1 and 5 only.
8. 7 and 4

### Q 6 : Which of the following is default integer primitive

1. short
2. int
3. byte
4. char
5. long

### Q 7 : Which of the following is not a reserved word in java
1. import
2. finally
3. **friend**
4. **goto**


### Q 8 : When writing a utility class, someclass, which extends mainclass class and will be used by several other classes in a large project. These other classes will be in different packages.Pick the correct class declaration

1. class someclass extends mainclass
2. protected class someclass extends mainclass
3. **public class someclass extends mainclass**
4. none


### Q 9 : Which of the following variable names are invalid?

1. example
2. **2sumup**
3. its4u
4. $money

### Q 10 : Take a look at the following code:

```java
       public static void main (String[] args){

       System.out.println(args[1]);

}
```
The above is compiled and then executed by the following command line.

```java
java test one two three four
```

1. one
2. two
3. three
4. four
5. none.

# Answers
----
Q 1 : 3 is correct.

Q 2 : 3 is correct. Substitute no_of_bits = ( 8 for byte , 16 for short, 16 for char, 32 for int, 64 for long, 32 for float, 64 for double).We get (2^7) / (2^7) -1 for int and so on for other types.

Q 3 : 2 is correct. primitive boolean keyword is ‘boolean’ and boolean can be only ‘true’ or ‘false’.

Q 4 : 3 is correct. there is nothing like explicit declaration for default package. The class is added to default package if there is no package statement..

Q 5 : 8 is correct. Valid declaration for the main() method must be public and static, have void as return type and take a single array of String objects as arguments. The order of public and static keywords is irrelevant. Also declaring the method final does not effect the method’s potential to be used as a main() method..

Q 6 : 2 is correct.

Q 7 : 3 is correct. There are no friend functions as in C++.

Q 8 : 3 is correct.

Q 9 : 2 is correct.

Q 10 : 2 is correct. Array index start from 0. So somearray[0] points to the first element in the array.

# OCPJP 6 Mock Exam – 6
----

### 1 . Please select signed integrals
1. char, byte, and short
2. byte, short, int, and long 
3. char, short, and long

### 2 . Java characters are ...
1. ASCII code 
2. Binary code 
3. Unicode
4. ANSI code

### 3 . Please select the size of an int type
1. 32 bytes 
2. 16 bits 
3. 32 bits 
4. 16 bytes

### 4 . Select default value of boolean type

1. true
2. false
3. 0
4. 1

### 5 . Consider the following line of code:

```java
<br />char x[]=new char[10];<br />
```

After execution, what is value of x[0]?


1.    0
2.    ‘\u0000’
3.    null



### 6 . A package statement MUST exist in all classes


1.    True

2.    False


### 7 . Please choose invalid identifiers


1.    temp

2.    BIGint

3.    25_length

4.    !length


### 8 . Please select floating point types


1.    byte

1.    int

1.    double

1.    short

1.    long

1.    float


### 9 . All operands are evaluated left to right


1.    true

1.    false


### 10 . Consider the following line of code:

```java
<br />byte x=64;<br />byte y=5;<br />byte z= (byte)(x*y);<br />
```

After execution what is value of z?


1.    320

1.    0

1.    645

1.    64



### 11 . Consider the following line of code:

```html
<br />int x=7;<br />int y=4;<br />int z=7/4;<br />
```

 After execution what is value of z?


1.    1.75

1.    0

1.    1

1.    2


### 12 . Please select the true statement for ! operator


1. The ! operator inverts the value of a boolean expression

1. The ! operator inverts the bit pattern of an integral expression.

1. Both A and B

1. None of the above




### 13 . Please select arithmetic operations which can result in AirthmeticException


1. Multiplication: *

1. Division: /

1. Modulo: %

1. Addition: +

1. Subtraction: –


### 14 . Please select operators which perform bit shifts of the binary representation of the integral types


1. <<

1. _>>_

1. _>>>_

1. ~

1. &

1. ^

1. _|_


### 15 . A protected method may be overridden by …


1. A private method

1. A protected method

1. A public method

1. All of the above


### 16 . A public method may not be overridden by …


1. A private method

1. A protected method

1. A public method

1. All of the above


### 17 . The private modifier can be applied to …


1. A variable

1. A method

1. A top level class

1. All of the above


### 18 . The abstract modifier can NOT be applied to …


1. A variable

1. A method

1. A class

1. A constructor


### 19 . A class variable is declared using following modifiers


1. protected

1. private

1. public

1. static


### 20 . An unary operator operates on a single value


1. True

1. False


### 21 . The following types of loop are guaranteed to be executed at least once


1. The do loop

1. The while loop

1. The for loop

1. All of the above


### 22 . The switch() construct is used to make a choice based upon …


1. A char value

1. An int value

1. A String value

1. None of the above


### 23 . The circumstances that can prevent execution of the code in a finally block are


1. The death of the thread

1. The use of System.exit()

1. It is always guaranteed to be executed.


### 24 . Select correct statement(s)


1. The continue statement abandons the loop altogether

1. The break statement causes the current iteration of the loop to be abandoned.

1. The break statement abandons the loop altogether


### 25 . How can you declare a overloaded method?


1. Reusing the method name with different arguments and same return type

1. Reusing the method name with different arguments and different return type

1. Reusing the name with identical arguments and return type

1. None of the above


### 26 . How can you declare a overriding method?


1. Using the same method name with identical arguments and return type

1. Using the same method name with identical arguments and different return type

1. Using the same method name with different arguments and same return type

1. All of the above


### 27 . When a default constructor is provided by the compiler?


1. If you define no constructor at all in a class

1. When you define at least one constructor

1. It is always provided whether you define a constructor or not

1. It is never provided


### 28 . A static inner class can access …


1. instance variables of the enclosing class

1. static variables of the enclosing class

1. Both A and B

1. None of the above


### 29 . An inner class created inside a method can access


1. Any local variables of a method that contain an inner class.

1. Any instance variables of the enclosing class

1. Any final variables of the enclosing class or a method that contain an inner class.

1. None of the above


### 30 . Please select true statement(s) for an anonymous inner class


1. An anonymous class can not extend to a superclass

1. An anonymous class can not implement an interface

1. An anonymous class can extend to a supperclass and implement an interface both.

1. An anonymous class can extend to a supperclass or implement an interface


### 31 . Please select true statement(s) for a member inner class


1. An inner class in class scope can have any accessibility of the top level class, including private.

1. An Inner class defined local to a block may be static

1. An anonymous inner class can not declare a constructor.

1. An inner class can not have same name as enclosing class.

1. All of the above


### 32 . Please select invalid statement(s) for a thread


1. You can restart a dead thread

1. You can’t call the methods of a dead thread

1. Both of the above

1. None of the above


### 33 . Select correct statements for a java.lang.String


1. Strings are sequences of 16 bit Unicode characters.

1. Strings are immutable.

1. Both of the above

1. None of the above


### 34 . Select correct statements for == operator.


1. It compare object reference of two objects

1. It compare the value of two objects

1. Both of the above

1. None of the above


### 35 . Please select collection(s) that do not reject duplicates


1. java.util.List

1. java.util.Set

1. java.util.Map

1. All of the above


### 36 . Please select a default layout manager of the java.awt.Panel


1. java.awt.FlowLayout with left justified

1. java.awt.FlowLayout with center justified

1. java.awt.FlowLayout with right justified

1. None of the above


### 37 . Please select a default layout manager for the java.awt.Frame


1. java.awt.FlowLayout

1. java.awt.BorderLayout

1. java.awt.GridBagLayout

1. None of the above


### 38 . Please select true statement for prefix operator(++x/–x).


1. The prefix operator(++x/–x) evaluates the value of the operand after increment/decrement operation.

1. The prefix operator(++x/–x) evaluates the value of the operand before increment/decrement operation.

1. Both A and B

1. None of the above


### 39 . Please select true statement(s) for shift operators.


1. _>>>_ operator always produces a positive number.

1. _>>_ always produces a positive number for a positive number.

1. _>>_ always produces a negative number for a negative number.

1. None of the above


### 40 . Please select true statement(s) for shift operators.

1. Shifting is not allowed in long integral type

1. Shifting is not allowed in float integral type

1. Shifting is not allowed in double integral type

1. Shifting is not allowed in int integral type.


### 41 . Please identify correct assignment for boolean type.


1. boolean javaExam=true;

1. boolean javaExam=True;

1. boolean javaExam=1;

1. All of the above


### 42 . Bitwise operator can be applied to …


1. Integral types

1. Float types

1. Both of the above

1. None of the above


### 43 . instanceof operator can be used with …


1. interfaces

1. Arrays

1. Classes

1. All of the above


### 44 . Please select true statement(s)


1. The equals method compares content of two objects

1. The == operator tests reference of two objects

1. The equals method compares reference of two objects.

1. The == operator compares content of two objects


### 45 . Please identify invalid use of comparison operator for the following code:

```html
<br />String s=new String("S");<br />String t=new String("T");<br />int x=83;<br />int y=84;<br />
```

 Choose the one below:


1. s == t

1. x!=y

1. x==s

1. s!=t


### 46 . Please select true statement(s) for instanceof operator:


1. The instanceof operator can be applied to object reference

1. The instanceof operator can be applied to an array.

1. Both of the above

1. None of the above


### 47 . please select true statement(s) for static modifier.


1. A static method can access non-static variables of the class.

1. A static method can call non-static methods.

1. A static method can be overridden by non-static method.

1. None of the above


### 48 . Please, select true statement(s) for thread.


1. Invoking a constructor of a Thread registers the thread with thread scheduler.

1. Calling a start() method of thread registers the thread with thread scheduler.

1. Calling a run() method of thread registers the thread with thread scheduler.

1. All of the above.


### 49 . Invoking yield() on a running thread cause following effect(s):


1. A running thread will be placed in suspended state.

1. A running thread will be placed in sleeping state.

1. A running thread will be placed in ready state.

1. Neither of the above.


### 50 . The default priority of the thread is


1. 0

1. 1

1. 5

1. 10


### 51 . Which of the following methods are NOT static of Thread class?


1. start()

1. sleep(long l)

1. run()

1. yield()


### 52 . Select true statement(s) about an inner class declared inside a method, also known as local inner class


1. The local inner class can access any local variables declared in the method and the parameters passed to the method.

1. The local inner class can access only public variables declared in enclosing class

1. The local inner class can access public, private, and protected variables declared in enclosing class.

1. The local inner class can access only final declared variables in the method.


### 53 . How can you prevent class JavaExam from being extended?


1. declare class static JavaExam

1. declare class synchronized JavaExam

1. declare class final JavaExam

1. None of the above


### 54 . Assume that following methods are declared in one class.
 
 ```java
 1. public void addElement(Object javaExam)
 2. public void addElement( Object [] javaExam)
 3. public Object addElement ( int index, Object javaExam)
 ```
 
 Please select true statement(s) for above methods.


1. All methods are example of overloading method

1. All methods are example of overriding method

1. Method # 1 and method # 2 are example of overloading method, whereas method # 3 is an example of overriding method.

1. None of the above


### 55 . When can’t you override a method?


1. when method is declared abstract

1. When method is declared final

1. when method is declared private

1. when method is declared static


### 56 . Please select invalid declaration of the top level class


1. public abstract final class JavaExam

1. public final class JavaExam implement Runnable

1. protected static class JavaExam

1. public class JavaExam extend Thread


### 57 . Please select invalid types for a switch construct


1. float

1. long

1. String

1. All of the above


### 58 . Please select invalid java keywords


1. include

1. ifdef

1. sizeof

1. goto


### 59 . Which of the following statements are NOT true about Java garbage collection Thread?


1. The garbage collection thread has a low priority

1. The garbage collection thread can be invoked at any time

1. A call to System.gc() is guaranteed to invoke garbage collection thread immediately

1. A call to Runtime.getRuntime().gc() is guaranteed to invoke garbage collection thread immediately


### 60 . An inner class can not declare______ variables.


1. static

1. protected

1. final

1. transient


### 61 . Which of the following types can be added to java.util.Vector?


1. reference

1. null

1. int

1. All of the above


### 62 . Please select a true statement about delete() method of java.io.File.


1. It can delete a file

1. It can delete an empty directory

1. Both of the above

1. Neither of the above


### 63 . The continue statement causes the current iteration of the loop to be skipped and the next iteration starts.


1. True

1. False


### 64 . The return type of constructor is void.


1. True

1. False


### 65 . ‘null’ is valid java type.


1. True

1. False


### 66 . Invoking a constructor of java.io.File class creates a file on the file system.


1. True

1. False


### 67 . Select true statement(s) about native modifier.


1. native modifier can be applied to a class

1. native modifier can be applied to a method

1. native modifier can be applied to an instance variable

1. native variable can be applied to a class variable


### 68 . What method(s) needed to be declared by a class implementing Runnable interface?


1. public void start()

1. public void run()

1. public boolean start()

1. public boolean run()


### 69 . The priority of a newly created thread is always Thread.NORM_PRIORITY.


1. True

1. False


### 70 . What methods are declared in java.lang.Thread class?


1. public static void sleep(long millis, int nanos)

1. public static native void sleep(long millis, int nanos)

1. public static native void sleep(long millis)

1. public static void sleep(long millis)


### 71 . A yield method of the Thread class suspends the operation of the current thread.


1. True

1. False


### 72 . What methods are NOT synchronized in java.util.Vector class?


1. size()

1. add(int index, Object element)

1. capacity()

1. get(int index)


### 73 . Please select unchecked exception(s)?


1. java.lang.NullPointerException

1. java.lang.ClassNotFoundException

1. java.lang.ClassCastException

1. java.awt.AWTException


### 74 . Which of the following declarations are valid to throw an exception?


1. throw new java.lang.Exception();

1. throws new java.lang.Exception();

1. Both of the above

1. None of the above


### 75 . Which of the following classes are immutable?


1. java.lang.String

1. java.lang.StringBuffer

1. java.util.Vector

1. java.lang.Integer


### 76 . Which of the following classes store and retrieve values based on a key?


1. java.util.Hashtable

1. java.util.Vector

1. java.util.LinkedList

1. java.util.HashMap


### 77 . Which of the following classes can store null value for a key?


1. java.util.Hashtable

1. java.util.HashMap

1. java.util.Properties

1. All of the above


### 78 . java.util.Vector uses synchronized methods to store and retrieve values.


1. True

1. False


### 79 . java.util.Hashtable uses synchronized methods to store and retrieve values.


1. True

1. False


### 80 . java.util.HashMap uses synchronized methods to store and retrieve values.


1. True

1. False


### 81 . Which of the following collections maintain object references in the order they were added?


1. java.util.Vector

1. java.util.Hashtable

1. java.util.HashMap

1. java.util.ArrayList


### 82 . java.util.hashtable implements which of the following interfaces?


1. java.util.Dictionary

1. java.util.Map

1. java.util.HashMap

1. java.util.Hashmap

# Answers
----

 1 : 2 is correct. 

 2 : 3 is correct. 

 3 : 3 is correct. 

 4 : 2 is correct. 

 5 : 2 is correct. 

 6 : 2 is correct. 

 7 : 3 & 4 is correct. 

 8 : 3 & 6 is correct. 

 9 : 1 is correct. 

 10 : 4 is correct. A byte value can represent a range of -128 to +127. Arithmetically answer is 320, but when you store this result to a byte variable you will get a value 64 since result is out of the range (-128 to +127).

 11 : 3 is correct. 

 12 : 1 is correct. 

 13 : 2 & 3 is correct. 

 14 : 1,2 & 3 is correct. 

 15 : 2 & 3 is correct. 

 16 : 1 & 2 is correct. 

 17 : 1 & 2 is correct. 

 18 : 1 & 4 is correct. 

 19 : 4 is correct. 

 20 : 1 is correct. + and – operator can take two values.

 21 : 1 is correct. 

 22 : 1 & 2 is correct. 

 23 : 1 & 2 is correct. 

 24 : 3 is correct. 

 25 : 1 & 2 is correct. 

 26 : 1 is correct. 

 27 : 1 is correct. 

 28 : 2 is correct. 

 29 : 3 is correct. 

 30 : 4 is correct. 

 31 : 1,3 & 4 is correct. 

 32 : 3 is correct. 

 33 : 3 is correct. 

 34 : 1 is correct. 

 35 : 1 is correct. 

 36 : 2 is correct. 

 37 : 2 is correct. 

 38 : 1 is correct. 

 39 : 2 & 3 is correct. 

 40 : 2 & 3 is correct. 

 41 : 1 is correct. 
 
  42 : 1 is correct. 

 43 : 4 is correct. 

 44 : 1 & 2 is correct. 

 45 : 3 is correct. 

 46 : 3 is correct. 

 47 : 4 is correct. 

 48 : 2 is correct. 

 49 : 3 is correct. 

 50 : 3 is correct. 

 51 : 1 & 3 is correct. 

 52 : 3 & 4 is correct. 

 53 : 3 is correct. 

 54 : 1 is correct. 

 55 : 2 is correct. 

 56 : 1,2,3 & 4 is correct. 

 57 : 4 is correct. 

 58 : 1,2 & 3 is correct. 

 59 : 2,3 & 4 is correct. 

 60 : 1 is correct. 

 61 : 1 & 2 is correct. 

 62 : 3 is correct. 

 63 : 1 is correct. 

 64 : 2 is correct. 

 65 : 1 is correct. 

 66 : 2 is correct. 

 67 : 2 is correct. 

 68 : 2 is correct. 

 69 : 2 is correct. A newly created thread inherits the priority of the Thread that creates it.

 70 : 1 & 3 is correct. 

 71 : 1 is correct. 

 72 : 1,2 & 3 is correct. 

 73 : 1 & 3 is correct. 

 74 : 1 is correct. 

 75 : 1 & 4 is correct. 

 76 : 1 & 4 is correct. 

 77 : 2 is correct. 

 78 : 1 is correct. 

 79 : 1 is correct. 

 80 : 2 is correct. 

 81 : 1 & 4 is correct. 

 82 : 2 is correct. 
 
# OCPJP 6 Mock Exam – 7
----
### 1 . Consider the following line of code:

```java
public class Test701 {
	public void main() {
		System.out.println("Hi");
	}

	public static void main(String[] args) {
		Test701 t = new Test701();
		t.main();
	}
}

```

What will be happen if you compile and run above code?

1.     It will not compile
2.     It will not run
3.     It will compile but will not run
4.     **It will output “Hi”**


### 2 . After execution of the code fragment below, what are the value of the variables x1, y1, and z1?

```java
int x=10; int y =10; int z=10; int x1, y1, z1;
x1=++y;
y1=z++;
z1=z;

```

Choose the one below:

1.     x1 = 10 , y1 = 10 and z1=10
2.     x1 = 10, y1 = 11, and z1=10
3.     x1=10, y1 = 10, and z1=11
4.     x1=11, y1=10, and z1=11

### 3 . What will be the output?


```java
package javainterview.java.scjp02;

/**
 * 
 * 
 * @author EMAIL:vuquangtin@gmail.com , tel:0377443333
 * @version 1.0.0
 * @see <a
 *      href="https://github.com/vuquangtin/javainterview">
 https://github.com/vuquangtin/javainterview</a>
 *
 */
public class Test702 {
	public int addTest(int x, int y) {
		x = x + 1;
		y = y + 1;
		int z = (x + y);
		return z;
	}

	public static void main(String[] args) {
		int x = 10;
		int y = 10;
		int z = 0;
		Test702 t = new Test702();
		z = t.addTest(x, y);
		System.out.println("x=" + x + ", y=" + y + ", z=" + z);
	}
}

```

1.     x=10, y=10, z=22
2.     x=11, y=11, z=22
3.     x=10, y=10, z=20
4.     x=11, y=11, z=20

### 4 . What will be the output of the program.?
Assume that MyList class is declared in MyList.java and ListManager class is declared in ListManager.java file.


```java
public class MyList {
	int size = 1;

	public static void main(String[] args) {
		MyList list = new MyList();
		list.size = 10;
		ListManager lm = new ListManager();
		lm.expandList(list);
		System.out.println("list.size=" + list.size);
	}
} // end of MyList

class ListManager {
	public void expandList(MyList l) {
		l.size = l.size + 10;
	}
}// end of ListManager
```

1.     list.size=0
2.     list.size=10
3.     list.size=11
4.     **list.size=20**

### 5 . If int x = -1 then which of the following expression results in a positive value in x?

1.     x=x>>>32
2.     x=x>>>5
3.     x=x>>5
4.     x=~x


### 6 . Which of the following lines of code would print “Equal” when you run it?

1.     int x=1; float y=1.0F; if(x==y){ System.out.println(“Equal”);}
2.     int x=1; Integer y= new Integer(1); if(x==y) { System.out.println(“Equal”);}
3.     Integer x=new Integer(1); Integer y=new Intger(1); if(x==y){ System.out.println(“Equal”);}
4.     String x=”1″; String y=”1″; if (x==y) { System.out.println(“Equal”);}




### 7 . Which of the following declarations are correct for the top level class?

1.     public synchronized class MyTest extends Thread
2.     private class MyTest extends Thread
3.     public abstract class MyTest extends Thread
4.     class MyTest extends Thread


### 8 . Consider the following lines of code:


```java
public class Test708 {
	String x;

	public void testDemo(int n) {
		String y;
		if (n > 0) {
			y = "Hello";
		}
		System.out.println(x + y);
	}

	public static void main(String[] args) {
		Test708 test = new Test708();
		test.testDemo(2);
	}
}
```

What will happen if you try to compile and run above code?

1.     **It will produce compiler warning that variable y may not have been initialized**
2.     It will produce compiler warning that variable x may not have been initialized
3.     It will output “Hello”
4.     It will output “nullHello”


### 9 . Consider that Parent and Child classes are defined in two different files as below:


```java
class Parent {
	public Parent() {
		System.out.println("I am Parent");
	}
}

public class Child extends Parent {
	public Child(int x) {
		System.out.println("I am Child");
	}

	public static void main(String[] args) {
		Child c = new Child(10);
	}
}

```

What will be output if you try to compile and run above code?

1.     It will not compile.
2.    **It will compile successfully. It will output “I am Parent” and then “I am Child.”**
3.     It will compile successfully. It will output “I am Child” and then “I am Parent.”
4.     It will compile successfully, but will not run.

### 10 . Consider following code:


```java
public class MyList710 {
	static int size;

	public void expandList(int newSize) {
		ListExpander lexp = new ListExpander();
		Vector expandedList = lexp.expand();
		class ListExpander {
			public Vector expand() {
				Vector v = new Vector(this.size + newSize);
				return v;
			}
		}
	}
}
```

What will happen if you attempt to compile above code?

1.     compiler error, “cannot refer inside an inner class to a static variable.”
2.     compiler error, “cannot refer inside an inner class to to a non-final variable newSize defined in a different method.”
3.     Both of the above
4.    **None of the above**


### 11 . Consider following code:


```java
public class Parent {
		public int size = 0;

		static class InnerClass {
			public void incrementParentSize() {
				XXX = XXX + 10;
			}
		}
	}
```

In above code, how can you access ‘size’ variable (of outer class Parent) inside innerclass at the place of ‘XXX’ ?

1.     super.size
2.     this.size
3.     Parent.size
4.     **Can not access it** ```Cannot make a static reference to the non-static field size```


### 12 . Assume that Parent and Child classes are in different files:


```java
public class Parent {
		public Parent(int x, int y)
		{
		       System.out.println("Created Parent");
		}
	}// end of Parent class

	public class Child extends Parent {
		public Child(int x, int y) {
			//
		}

		public Child(int x, int y, int z){
		System.out.println("Creating child");
		this(x,y);
		}

		public static void main(String[] args) {
			Child c = new Child(1, 2, 3);
		}
	}
```

What will happen if you try to compile and run above program?

1.     It will compile successfully. It will output “Created Parent” and then “Creating child”
2.     It will compile successfully. It will output “Creating child” and then “Created Parent”
3.     **It will not compile giving warning, “Explicit constructor invocation must be first statement in constructor.”**
4.     It will not compile giving warning, “Expression is not a valid block statement.”


### 13 . Consider following code:


```java
public class OuterClass {
		class InnerClass {
		}

		public void innerClassDemo() {
			// Explicit instance of InnerClass
		}
	}
```

In above code, how can you explicitly create an instance of InnerClass?

1.     InnerClass i=InnerClass();
2.     InnerClass i=OuterClass.InnerClass();
3.     **InnerClass i=new OuterClass ().new InnerClass();**
4.     OuterClass.InnerClass i=new OuterClass.InnerClass();

### 14 . Please select valid array declaration(s):

1.     int x[20];
2.     **int []x=new int[20];**
3.     **int [][] x=new int [20][];**
4.     **int [][][] x=new int[20][20][20];**
5.     **int [] x={1,2,3};**



### 15 . Consider following code:


```java
public class Test715 {
	protected void demo() throws NumberFormatException,
			ArrayIndexOutOfBoundsException {
		// something here
	}

	public void demo(String s) {
		// something here
	}
}// end of Test class
```

Please select true statement(s) for demo code?

1.     **It is an example of overloading method**
2.     It is an example of overriding method
3.     Both of the above
4.     None of the above

### For the following code, please consider that super class is defined in question #15:

```java
public class MyTest extends Test715 {
	private void demo() throws IndexOutOfBoundsException,
			ClassNotFoundException {
		// something here
	}
}// end of MyTest class
```

What will happen if you try to compile above code ?

1.     It will compile successfully.
2.     Compiler error: Exception java.lang.ClassNotFoundException in throws clause of void MyTest.demo() is not compatible with void Test.demo().
3.     **Compiler error: Cannot reduce visibility of the inherited method from Test.**
4.     Both B and C

>Multiple markers at this line
>
>- Exception ClassNotFoundException is not compatible with throws clause in 
	 Test715.demo()
>- Cannot reduce the visibility of the inherited method from Test715

### 17 . Consider the following code:


```java
public class Test717 {
	public void demo(String[] list) {
		try {
			String s = list[list.length + 1];
			System.out.println(s);
		} catch (ArrayIndexOutOfBoundsException e) {
			return;
		} finally {
			System.out.println("Finally here.");
		}
	}

	public static void main(String[] args) {
		Test717 t = new Test717();
		String[] list = { "one", "two" };
		t.demo(list);
		System.out.println("Done!");
	}
}// end of Test class
```

What happen if you try compile and run above code ?

1.     It will not compile.
2.     It will output “null” and then “Finally here.”
3.     It will output “Done!”
4.     **It will output “Finally here” and then “Done!”**


### 18 . Please consider following code:


```java
public class Test718 {
	public static void demo(String s) {
		debug("In demo:" + s);
	}

	private void debug(String s) {
		System.out.println(s);
	}

	public static void main(String[] args) {
		Test718.demo("Hello");
	}
}

```

What will happen if you try to compile and run above code ?

1.     It will compile successfully, but will not run.
2.     It will compile successfully, and outputs “In demo:Hello.”
3.     **It will not compile with error message “Can not make a static reference to the instance method named.”**
4.     None of the above

>Cannot make a static reference to the non-static method debug(String) from the type Test718

### 19 . Consider the following code:


```java
/** File Drawable.java */
interface Drawable {
	public void draw();

	public void fill();
}

/** End of file Drawable.java */

/** File Circle.java */
class Circle implements Drawable {
	int center = 0;

	public void draw() {
		System.out.println("Drawing circle");
	}

	public static void main(String[] args) {
		Circle c = new Circle();
		c.draw();
	}
}
/** End of file Circle.java */
```

If you attempt to compile and run Circle class what will be output?

1.     It will compile successfully, and outputs “Drawing circle.”
2.    **It will not compile, and reports error: “class Circle must implement inherited abstract method void Drawable.fill.”**
3.     It will not compile, and reports error: “Method Drawable.fill requires a body instead of a semicolon.”
4.     None of the above

>The type Circle must implement the inherited abstract method Drawable.fill()

### 20 . What will be the output?


```java
		int x = 2;
		int y = 3;
		int z = 4;
		if (x > 2) {
			System.out.println("Tested x");
		}
		if (y < 3) {
			System.out.println("Tested y");
		}
		if (z <= 3) {
			System.out.println("Tested z");
		}

```

Choose the one below:

1.     Tested x.
2.     Tested y.
3.     Tested z.
4.     **None of the above.**


### 21 . Consider the following code:


```java
	for( int i=0;i<2;i++)
		{
		      for(int j=i;j<3; j++)
		     {
		             if (i==j)
		             {
		                   continue;
		             }
		             System.out.println("i="+i+" j="+j);
		     }
		}
```

Which lines would be part of the output?

1.     **i = 0 j = 1**
2.     **i = 0 j = 2**
3.     **i = 1 j = 2**
4.     None of the above



### 22 . Consider the following code:


```java
		int j = 0;
		for (int i = 0; i < 2; i++) {
			for (j = i; j < 3; j++) {
				continue;
			}
			System.out.println("-->i = " + i + " j = " + j);
		}
```

Which lines would be part of the output?

1.     i = 0 j = 0
2.     i = 1 j = 1
3.     **i = 0 j = 3**
4.     **i = 1 j =3**


### 23. Consider the following code:


```java
	int i = 0;
		int j = 0;
		for (i = 0; i < 2; i++) {
			for (j = i; j < 3; j++) {
				break;
			}
			System.out.println("i = " + i + " j = " + j);
		}
```

Which lines would be part of the output?

1.     **i = 0 j = 0**
2.     **i = 1 j = 1**
3.     i = 0 j = 3
4.     None of the above


### 25 . Consider the following code:


```java
		int i, j = 0;

		for (i = 0; i < 2; i++) {
			inner: for (j = i; j < 3; j++) {
				break inner;
			}
			System.out.println("i = " + i + " j = " + j);
		}
```

Which lines would be part of the output?

1.     **i = 0 j = 0**
2.     **i = 1 j = 1**
3.     i = 0 j = 3
4.     None of the above



### 26 . What will be the output?


```java
Thread currentThread=Thread.currentThread();
		int priority = currentThread.getPriority();
		Thread t1=new Thread();
		t1.setPriority(9);
		ThreadGroup tgrp=new ThreadGroup();
		tgrp.setMaxPriority(10);
		Thread t2=new Thread(tgrp,"t2");
		System.out.println("Priority of t1="+t1.getPriority());
		System.out.println("Priority of t2="+t2.getPriority());
```

Choose the one below:

1.     Priority of t1=5 and Priority of t2=10
2.     Priority of t1=9 and Priority of t2=10
3.     Priority of t1=9 and Priority of t2=5
4.     Neither of above

>4.Neither of above ```The constructor ThreadGroup() is not visible```
>if new ThreadGroup();--->new ThreadGroup("name"); 

>- Priority of t1=9
>- Priority of t2=5

### 27 . Consider the following code:


```java
/** File Thread1.java */
class Thread1 implements Runnable {
	public void run() {
		System.out.println("Running Thread1");
	}
}

/** End of file Thread1.java */

/** Thread2.java */
public class Thread2 extends Thread {
	public void run() {
		System.out.println("Running Thread2");
	}

	public static void main(String[] args) {
		Thread1 t1 = new Thread1();
		Thread t2 = new Thread2(t1);
		t1.start();
		t2.start();
	}
}
/** End of Thread2.java */

```

If you try to compile and run above code what will be result?

1.     “Running thread1” following “Running thread2”
2.     “Running thread2” following “Running thread1”
3.     It will not compile because in Thread1 and Thread2 start() is not defined .
4.     **It will not compile because constructor invoked to create Thread2 with arguments (Thread1) is not defined**


### 28 . Consider the following code:


```java
public class MyThread extends Thread {
	public void run() {
		System.out.println("Done");
	}

	public void demo() {
		System.out.println("Demo");
	}

	public static void main(String args[]) {
		MyThread th = new MyThread();
		th.run();
		th.stop();
		th.demo();
	}
}
```

What will happen if you try to compile and run above code?

1.     It will throw an exception at th.run() because run() was called before calling start().
2.     It will throw an exception at th.demo() because Thread variable th was already stopped calling stop().
3.     It will output “Done” following “Demo”
4.     **Neither of the above.**

> output ```Done Demo``` stop se dc goi nhu pt thong thuong

### 29 . Please consider following code:


```java
String s1=" 5 + 5 = 10 ";
		s1.trim();
		s1.replace('+', '-');
```

How many String objects will be created after executing above code?

1.     1
2.     2
3.     **3**
4.     4


### 30 . What will be the output?


```java
		String s = "Hi";
		StringBuffer sb = new StringBuffer(s);
		String s1 = new String("There");
		StringBuffer sb1 = new StringBuffer(s1);
		if (s == sb) {
			System.out.println("s==sb");
		}
		if (s.equals(sb)) {
			System.out.println("s.equals(sb)");
		}
		if (s1.equals(sb1)) {
			System.out.println("s1.equals(sb1)");
		}
```

Choose the one below:

1.     **It will not compile at if(s==sb) because operands on both side are not compatible**
2.     A. It will print s1.equals(sb1)
3.     B. It will print s.equals(sb)
4.     C. It will compile successfully, but it will not output anything


### 31 . Consider that following code is declared in BussyThread.java file


```java
public class BussyThread extends Thread {
	public void run() {
		for (int i = 0; i > 10; i++) {
			i = i - 1;
		}// end of for loop
	}// end of run()

	public static void main(String args[]) {
		BussyThread b1 = new BussyThread();
		BussyThread b2 = new BussyThread();
		b1.start();
		b2.start();
	}
}// end of class
```

Above code will start two threads b1 and b2. Select True statements for above code?

1.     Only b1 thread will get chance to run
2.     Only b2 thread will get chance to run
3.     **Both thread will get chance to run sharing CPU time**
4.     Neither of the thread will be able to run.

### 32 . What changes in run() method of BussyThread will enable both threads to run?

1.     adding yield() into run method
2.     adding try{sleep(1000);}catch (InterruptedException e){} into run method
3.     adding wait(1000) into run method
4.     Neither of the above


### 33 . Consider the following classes are in MyThread.java, YourThread.java, and Driver.java files:


```java
class MyThread733 implements Runnable {
	public void run() {
		System.out.println("Running MyThread");
	}
}// end of MyThread

class YourThread extends Thread {
	public YourThread(Runnable r) {
		super(r);
	}

	public void run() {
		System.out.println("Running YourThread");
	}
}// end of YourThread

public class Driver {

	public static void main(String args[]) {
		MyThread t1 = new MyThread();
		YourThread t2 = new YourThread(t1);
		t2.start();
	}
}// end of class
```

If you try to run Driver class what will be result?

1.     It will output “Running MyThread.”
2.     **It will output “Running YourThread.”**
3.     It will output both “Running MyThread,” and “Running YourThread.”
4.     It will not run.

>You get "Running Your thread" because you've extended the Thread class and overide it's run method. t2.start calls the overridden run method of the yourThread class.

>Is it beacuse, since run() is overridden In YourThread, It executes the method of it's reference type..

>Thanx

good question ! nice
well.. the the reason to seemingly-strange output of above code lies in two factors ;

- The way Thread's start() n run() hav been implemented
- Polymorphism n inheritence

The ```Thread``` class ```start()``` method is ```native``` , all it does is it will instruct JVM to spawn a new-thread in which to run the ```run()``` method of this thread .
Now carefully look below at the way run method has been implemented ;

```java
public void run() {
	if (target != null) {
		target.run();
	}
}
```
>( target is the one which we pass as Runnable in Thread's constructor )

All i mean to say is that ```start()``` method just calls the ```run()``` method , it DO NOT checks whether a ```Runnable``` was passed or not , and if was passed then to call ```Runnable's run()``` method instead of Thread's run method , somehow by design-choice , this functionality has been kept in ```run()``` method of Thread, instead of ```start()```.

Now , when we extends Thread class , and override run() method , wht we get is a class with:

- start() method inherited from parent Thread()
- run() method of its own

A call to start() method on object of such a class , obviously spawan a new Thread with overriden run() method
> explanation to this lies in the property of Polymorphism , inheritence n method lookup tht is 

To make things understandable ( n experimentable , u cant bother to change original Thread implementation! ) , i have wrriten following code ,
Most of the hierachy corresponds to original thread classes , but i hav kept them simple according to our specific problem 
>

```java

interface Doable {// Corresponds to Runnable
	public void doit(); // this method corresponds to run()
}

class Work implements Doable { // Class Work coressponds to Thread
	Doable work;
	String name;

	public Work() {
		this("defaultname", null);
	} // Diff. constructors

	public Work(String name) {
		this(name, null);
	}

	public Work(Doable work) {
		this("defaultname", work);
	}

	public Work(String name, Doable work) {
		this.name = name;
		this.work = work;
	}

	public void start() {
		doit();
	} // Plain implementation of start , no JVM things of course

	public void doit() {
		if (work != null)
			work.doit();
	}; // Implemented same way as Original run() in Thread
}

/***** Rest of the example corresponds to Ashok's original code ***/
class MyWork implements Doable {
	public void doit() {
		System.out.println("Doing MyWork");
	}
}

class YourWork extends Work {
	public YourWork(Doable work) {
		super(work);
	}

	public void doit() {
		System.out.println("Doing YourWork");
	}
}

class MyThreadingTest {
	public static void main(String args[]) {
		MyWork w1 = new MyWork();
		YourWork w2 = new YourWork(w1);
		w2.start();
	}
}

```

not surprisingly , the output of above code is :

```
Doing YourWork
```

In bare-bones ,all wht-is-happening is due to design-choice , if instead of keeping runnable-check functionality in run() method (doing the target==null check n then calling its run) , if it wuld hav been kept in start() method , then result will hav been altogether diff.
Like in my code if we change start() n doit() method in Work class as :

```java
public void start() { if(work != null) work.doit(); else doit(); }
public void doit() { /* do nothing */ } ;
```

The the output changes to :

```
Doing MyWork
```

Read this code once or twice , n try to experiment it for urself , n i am sure , u ll get my point.
BTW , it is pity tht there are no marks in SCJp for asking questions ! otherwise i wuld hav whole heartily given Ashok full marks !
nice question , keep discussing these kinda things
have chillin preparation n Good Luck !


### 34 . Consider following code:


```java
		String s = null;
		String t = "null";
		if (s == t) {
			System.out.println("s equal to t");
		} else {
			System.out.println("s not equal to t");
		}
```

what will result if you try to compile and run above code?

1.     it compiles successfully, but throws NullpointerException at if (s==t)
2.     It will not compile.
3.     It compiles successfully and output “s equal to t”
4.     **It compiles successfully and output “s not equal to t”**


### 35 . Consider the following code:


```java
	public void demo() {
		String s[];
		if (s.equals(null)) {
			System.out.println("s is null");
		} else {
			System.out.println("s is not equal");
		}
	}
```

What will be result if you try to compile and run above code?

1.     **Compile error produced, “variable s may not have been initialized.”**
2.     It compile successfully, but throws NullpointerException at if ( s.equals(null) )
3.     It compile successfully, and outputs “s is null.”
4.     It compile successfully, and outputs “s is not null.”


### 36 . Consider the following code:


```java
public class MyList736 {
	private static final int MAX_SIZE = 10;
	private Object[] list = new Object[MAX_SIZE];

	public void add(Object obj) {
		int size = list.length;
		if (size >= MAX_SIZE) {

			class ListExpander {
				public void expand() {
					Object temp[] = list;
					list = new Object[size + MAX_SIZE];
					for (int i = 0; i < temp.length; i++) {
						list[i] = temp[i];
					}
				}// end of public void expand()
			}// end of class ListExpander
			ListExpander listEx = new ListExpander();
			listEx.expand();
			list[size] = obj;
		}// end of if
	}// end of add
}// end of class MyList
```

What will be result if you try to compile and run the above code?

1.     Compiler error reported, “Cannot refer inside an inner class to a non-final variable ‘size’ defined in a different method.”
2.     Compiler error reported, “Cannot refer inside an inner class to a private member variable ‘list’ defined in enclosing class MyList.”
3.     Compiler error reported, “Cannot refer inside an inner class to a static member variable MAX_SIZE defined in enclosing class MyList.”
4.     **It compiles and runs successfully.**


### 37 . Consider following example of an inner class:


```java
public class MyTest737 {
	public String publicVariable = "a";
	private String privateVariable = "b";
	public static int SIZE = 0;
	private static int MAX_SIZE = 0;

	public static class DemoHelper {
		public void demo() {
			System.out.println("Demo = " + XXX);
		}

	}// end of inner class
}
```

which variable of the MyTest class will be able to use in place of XXX?

1.     publicVariable
2.     privateVariable
3.     **SIZE**
4.     **MAX_SIZE**

### What will be result if you try to compile and run following code?


```java
public class Record extends String{}
```

Choose the one below:

1.     **Compiler error reported, “Can not extend a final class.”**
2.     Compiler error reported, “Must implement method int compareTo(Object).”
3.     Compile and run successfully.
4.     None of the above.


### 39 . Consider the following two classes:


```java
public class Parent {
	protected void demo() throws Exception {
	}
} // end of Parent class

class Child extends Parent {
	private void demo() {
	}
}
```

What will be result if you try to compile above two classes?

1.     **Compiler object for the method of a Child class, “Can not reduce the visibility of the inherited method.”**
2.     Compiler object for demo() method of a Child class, “Inherited method is not compatible with void Parent.demo() throws Exception.”
3.     Compile successfully.
4.     None of the above

>Cannot reduce the visibility of the inherited method from Parent
>

### 40 . Consider the following two classes:


```java
class Parent740 {
	protected void demo() {
	}
} // end of Parent class

public class Child740 extends Parent740 {
	public void demo() throws Exception {
	}
}

```

What will be result if you try to compile above two classes?

1.     Compiler object for the method of a Child class, “Can not widen the visibility of the inherited method.”
2.     **Compiler object for demo() method of a Child class, “Exception java.lang.Exception in throws clause of void Child.demo() is not compatible with void Parent.demo().”**
3.     Compile successfully
4.     None of the above

>Exception Exception is not compatible with throws clause in Parent740.demo()

### 41 . Consider the following two classes:


```java
class Parent741 {
	protected void demo() {
	}
} // end of Parent class

public class Child741 extends Parent741 {
	public int demo() {
		return 0;
	}
}
```

What will be result if you try to compile above two classes?

1.     Compiler object for the method of a Child class, “Can not widen the visibility of the inherited method.”
2.     **Compiler object for the method of a Child class, “Return type is not compatible with void Parent.demo().”**
3.     Compile successfully.
4.     None of the above

>The return type is incompatible with Parent741.demo()

### 42 . Consider the following two classes:


```java
class Parent742 {
	protected static void demo() {
	}
} // end of Parent class

public class Child742 extends Parent742 {
	public void demo() {
	}
}

```

What will be result if you try to compile above two classes?

1.     Compiler object for the method of a Child class, “Can not widen the visibility of the inherited method.”
2.     Compiler object for the method of a Child class, “inherited method void Child.demo() is not compatible with void Parent.demo().”
3.     **Compiler object for the method of a Child class, “The instance method can not override the static method from Parent.”**
4.     Compile successfully.

>This instance method cannot override the static method from Parent742

### 43 . Consider that class Employee and Salesman are in different file called Employee.java and Salesman.java:


```java
/** Employee.java file */
class Employee {
	int salary = 1000;

	public int getSalary() {
		return salary;
	}
}

/** End of Employee.java file */
/** Salesman.java file */
public class Salesman extends Employee {
	int commission = 100;

	public int getSalary() {
		return salary + commission;
	}

	public static void main(String[] args) {
		Salesman sm = new Salesman();
		Employee em = sm;
		System.out.println(em.getSalary());
	}
}
/** End of Salesman.java file */

```

What will be result if you try to compile and run above code?

1.     Compiler error reported , “Type mismatch: Cannot convert from Salesman to Employee.”
2.     It compile successfully and outputs 1000.
3.     **It compiles successfully and outputs 1100.**
4.     None of the above


### 44 . Considering following code what will be the result if you try to compile the following code:


```java
public abstract class Test744 {
	public void demo() {
		System.out.println("demo");
	}
}

```

Choose the one below:

1.     **It will compile successfully.**
2.     Compiler error reported, “An abstract method must be defined.”
3.     Compiler error reported, “Invalid declaration of class.”
4.     None of the above

### 45 . Considering following code what will be the result if you try to compile the following code:

```java
public class Test{
	public abstract void demo();
}

```

Choose the one below:

1.     Compiler error reported, “Method requires a body instead of semicolon.”
2.     **Compiler error reported, “Abstract methods are only defined by abstract classes.”**
3.     Compile successfully.
4.     None of the above.


### 46 . The GenericList has the following method:


```java
public void addItem(Object item)
```

You are writing a class GroceryList that extends GenericList. Which of the following would be legal declarations of overloading methods?

Choose the one below:

1.     **public void addItem(Vector item)**
2.     **public void addItem(Object [] items) throws Exception**
3.     protected void addItem(Object item)
4.     All of the above


### 47 . What will be result if you try to compile the following code?


```java
class Parent747 {
	String name = null;

	public Parent747(String n) {
		name = n;
	}
}

public class Child747 extends Parent747 {
	String type = "X";
}
```

Choose the one below:

1.     Compile successfully.
2.     Compiler error reported, because Parent class did not declare constructor with arguments ().
3.     Compiler error reported, because Child class did not declare a constructor.
4.     **Both of the above 2 and 3**


### 48 . What will be legal statement in the following method?


```java
public void demo(int x){
XXX y=10;
}

```

Choose the one below:

1.     public int
2.     **int**
3.     **final int**
4.     static int


### 49 . What will be result if you try to compile and run following code fragement?


```java
	public void demo(String[] args) {
		int i = 1;
		for (int i = 0; i < args.length; i++) {
			System.out.println(args[i]);
		}
	}
```

Choose the one below:

1.     Compile successfully, but throws IndexOutOfBoundException during runtime.
2.     **Compile error reported, “Local name i is already defined.”**
3.     Throws NullPointerException during runtime
4.     None of the above

>Duplicate local variable i

# Answers
----

1 : 4 is correct.

2 : 4 is correct.

3 : 1 is correct.

4 : 4 is correct.

5 : 2 & 4 is correct.

6 : 1 & 4 is correct.

7 : 3 & 4 is correct.

8 : 1 is correct.

9 : 2 is correct.

10 : 2 is correct.

11 : 4 is correct.

12 : 3 & 4 is correct.

13 : 3 & 4 is correct.

14 : 2,3,4 & 5 is correct. 
 15 : 1 is correct.

16 : 4 is correct. This is an example of overriding method.

17 : 4 is correct.

18 : 3 is correct.

19 : 2 is correct.

20 : 4 is correct.

21 : 1,2 & 3 is correct.

22 : 3 & 4 is correct.

23 : 1 & 2 is correct.

24 : 4 is correct.

25 : 1 & 2 is correct.

26 : 3 is correct.

27 : 4 is correct.

28 : 3 is correct.

29 : 3 is correct.

30 : 1 is correct.

31 : 3 is correct.

32 : 1 & 2 is correct.

33 : 2 is correct.

34 : 4 is correct.

35 : 1 is correct.

36 : 1 is correct.

37 : 3 & 4 is correct.

38 : 1 is correct.

39 : 1 is correct.

40 : 2 is correct.

41 : 2 is correct.

42 : 3 is correct.

43 : 3 is correct.

44 : 1 is correct.

45 : 2 is correct.

46 : 1 & 2 is correct.

47 : 2 is correct.

48 : 2 & 3 is correct.

49 : 2 is correct. 

### 


```java
```


### 


```java
```


### 


```java
```


### 


```java
```


### 


```java
```


### 


```java
```



### 


### 


### 


### 

### 


### 


### 


### 


### 

### 


### 


### 


### 


### 

### 


### 


### 


### 


### 

### 


### 


### 


### 


### 

### 


### 


### 


### 


### 

### 


### 


### 


### 


### 




